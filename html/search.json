[
  {
    "objectID": "ai.html",
    "href": "ai.html",
    "title": "Artificial Intelligence",
    "section": "",
    "text": "Before we jump into the textbook, we should cover a few basic aspects of programming that the reader may not know. These are some of the most essential terms and concepts that you will see used throughout this textbook. Remember, you can always come back to this section if you forget one of these terms."
  },
  {
    "objectID": "ai.html#the-print-function",
    "href": "ai.html#the-print-function",
    "title": "Artificial Intelligence",
    "section": "The Print Function",
    "text": "The Print Function\nThe very first thing that every programmer learns is how to print something off using that programming language. In most tutorials, you will see the phrase “Hello, World!” used. In this textbook, let’s try something a bit different. Let’s say I wanted to print off “Hello, William”. We can do this in Python by using the print function. The print function lets us print off some piece of data. In our case, that piece of data will be a piece of text, known as a string (see below). Our text is “Hello, William”. The thing that we want to print off must be located between an open parentheses and a close parentheses. Let’s try to execute the print command in the cell below.\n\nprint(\"Hello, William!\")\n\nHello, William!\n\n\nAs we can see, the code that we typed in the Jupyter cell outputted beneath it. Now, it is your turn. Try to print off something. In order to print off text, you will need to use an open and a close quotation mark. We will learn more about this as we meet strings in the next chapter.\n\nfrom IPython.display import IFrame\nIFrame('https://trinket.io/embed/python3/3fe4c8f3f4', 700, 500)\n\n\n        \n        \n\n\nThis has worked wonderfully, but what if our Python notebook needs to be more dynamic, meaning it needs to adjust based on some user input. Perhaps, we need to use a name other than William based on some user-defined input. To do this, we would need to store a piece of data in memory. We can do this in Python by creating a variable that will point to an object. Before we get into how this is done, let’s first get to know objects and variables."
  },
  {
    "objectID": "ai.html#objects",
    "href": "ai.html#objects",
    "title": "Artificial Intelligence",
    "section": "Objects",
    "text": "Objects\nWhen we import or create data within Python, we are essentially creating an object in memory with a variable. These two words, object and variable mean slightly different things, but are often used interchangeably. We will not get into the complexities of their differences and why they exist in this textbook, but for now, view an object as something that is created by a Python script and stored in your computer’s memory so that it can be used later in a program.\nThink of your computer’s memory rather like your own brain. Imagine if you needed to remember what the word for “hello” in German. You may use your memory rather like a flashcard, where “hello” in English equates to “hallo” in German. In Python, we create objects in a similar way. The object would be the dictionary entry of “hello: hallo”."
  },
  {
    "objectID": "ai.html#variables",
    "href": "ai.html#variables",
    "title": "Artificial Intelligence",
    "section": "Variables",
    "text": "Variables\nIn order to reference this dictionary entry in memory, we need a way to reference it. We do this with a variable. The variable is simply the name of the item in our script that will point to that object in memory. Variables make it so that we can have an easy-to-remember name to reference, call, and change that object in memory.\nVariables can be created by typing a unique word, followed by an = sign, followed by the specific data. As we will learn throughout this chapter, there are many types of data that are created differently. Let’s create our first object before we begin. This will be a string, or a piece of text. (We will learn about these in more detail below.) In my case, I want to create the object author. I want author to be associated with my name in memory. In the cell, or block of code, below, let’s do this.\n\nauthor = \"William Mattingly\"\n\nExcellent! We have created our first object. Now, it is time to use that object. Below, we will learn about ways we can manipulate strings, but for now, let’s simply see if that object exists in memory. We can do this with the print function.\nThe print function will become your best friend in Python. It is, perhaps, the function I use most commonly. The reason for this is because the print function allows for you to easily debug, or identify problems and fix them, within your code. It allows us to print off objects that are stored in memory.\nTo use the print function, we type the word print followed by an open parentheses. After the open parentheses, we place the object or that piece of data that we want to print. After that, we close the function with the close parentheses. Let’s try to print off our new object author to make sure it is in memory.\n\nprint(author)\n\nWilliam Mattingly\n\n\nNotice that when I execute the cell above, I see an output that relates to the object we created above. What would happen if I tried to print off that object, but I used a capital letter, rather than a lowercase one at the beginning, so Author, rather than author?"
  },
  {
    "objectID": "ai.html#case-sensitivity",
    "href": "ai.html#case-sensitivity",
    "title": "Artificial Intelligence",
    "section": "Case Sensitivity",
    "text": "Case Sensitivity\n\nprint(Author)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nInput In [3], in &lt;cell line: 1&gt;()\n----&gt; 1 print (Author)\n\nNameError: name 'Author' is not defined\n\n\n\nThe scary looking block of text above indicates that we have produced an error in Python. This mistake teaches us two things. First, Python is case sensitive. This means that if any object (or string) will need to be matched in not only letters, but also the case of those letters. Second, this mistake teaches us that we can only call objects that have been created and stored in memory.\nNow that we have the variable pointing to a specific piece of data, we can make our print function above a bit more dynamic. Let’s try and print off the same statement as before, but with the new full author name. I don’t expect you to understand the specifics of the code below, rather simply understand that we will frequently need to store variables in memory so that we can use them later in our programs.\n\nprint(f\"Hello, {author}!\")\n\nHello, William Mattingly!"
  },
  {
    "objectID": "ai.html#reserved-words",
    "href": "ai.html#reserved-words",
    "title": "Artificial Intelligence",
    "section": "Reserved Words",
    "text": "Reserved Words\nWhen working with Python, there are a number of words known as reserve words. These are words that cannot be used as variable names. As of Python version 3.6, there are a total of 33 reserve words. In can sometimes be difficult to remember all of these reserve words, so Python has a nice built in function, “help”. If we execute the following command, we will see an entire list.\n\nhelp(\"keywords\")\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nThese are words that you cannot use as a variable name."
  },
  {
    "objectID": "ai.html#built-in-types",
    "href": "ai.html#built-in-types",
    "title": "Artificial Intelligence",
    "section": "Built-in Types",
    "text": "Built-in Types\nIn addition to reserve words, there are also built-in types in Python. These are words that you can use (as we will see) to convert one type of data into another. There are 94 of these in total. Unlike reserve words, you can use a built-in type as a variable name. It is, however, strongly discouraged to do so because it will overwrite the intended use of these variable names in your script.\n\nimport builtins\n[getattr(builtins, d) for d in dir(builtins) if isinstance(getattr(builtins, d), type)]\n\n[ArithmeticError,\n AssertionError,\n AttributeError,\n BaseException,\n BlockingIOError,\n BrokenPipeError,\n BufferError,\n BytesWarning,\n ChildProcessError,\n ConnectionAbortedError,\n ConnectionError,\n ConnectionRefusedError,\n ConnectionResetError,\n DeprecationWarning,\n EOFError,\n OSError,\n Exception,\n FileExistsError,\n FileNotFoundError,\n FloatingPointError,\n FutureWarning,\n GeneratorExit,\n OSError,\n ImportError,\n ImportWarning,\n IndentationError,\n IndexError,\n InterruptedError,\n IsADirectoryError,\n KeyError,\n KeyboardInterrupt,\n LookupError,\n MemoryError,\n ModuleNotFoundError,\n NameError,\n NotADirectoryError,\n NotImplementedError,\n OSError,\n OverflowError,\n PendingDeprecationWarning,\n PermissionError,\n ProcessLookupError,\n RecursionError,\n ReferenceError,\n ResourceWarning,\n RuntimeError,\n RuntimeWarning,\n StopAsyncIteration,\n StopIteration,\n SyntaxError,\n SyntaxWarning,\n SystemError,\n SystemExit,\n TabError,\n TimeoutError,\n TypeError,\n UnboundLocalError,\n UnicodeDecodeError,\n UnicodeEncodeError,\n UnicodeError,\n UnicodeTranslateError,\n UnicodeWarning,\n UserWarning,\n ValueError,\n Warning,\n OSError,\n ZeroDivisionError,\n _frozen_importlib.BuiltinImporter,\n bool,\n bytearray,\n bytes,\n classmethod,\n complex,\n dict,\n enumerate,\n filter,\n float,\n frozenset,\n int,\n list,\n map,\n memoryview,\n object,\n property,\n range,\n reversed,\n set,\n slice,\n staticmethod,\n str,\n super,\n tuple,\n type,\n zip]\n\n\nOf this long list, I recommend paying particular attention to the ones that you are more likely to write naturally: bool, dict, float, int, list, map, object, property, range, reversed, set, slice, str, super, tuple, type, and zip. You are more likely to use these as variable names by accident than, say, ZeroDivisionError; and this shorter list is a lot easier to memorize."
  },
  {
    "objectID": "ai.html#type-function",
    "href": "ai.html#type-function",
    "title": "Artificial Intelligence",
    "section": "Type Function",
    "text": "Type Function\nIt is frequently necessary to check to see what type of data a variable is. To identify this, you can use the built-in function type in Python. To use type, we use the command below with the data we want to analyze placed between the two parentheses.\n\ntype(\"this is a string...\")\n\nstr"
  },
  {
    "objectID": "ai.html#bugs",
    "href": "ai.html#bugs",
    "title": "Artificial Intelligence",
    "section": "Bugs",
    "text": "Bugs\nThroughout your programming career, you will often read or hear about bugs. A bug is a problem in your code that either returns an error or an unintended result in the output. Tracing down bugs and fixing them is known as debugging. Aside from figuring out how to code solutions to problems, debugging can be one of the more time-consuming aspects of writing a program, especially if it is quite complex. Throughout this textbook, we will encounter common errors so that you can see them in this controlled space. We will also walk through what the error means and how to resolve it. That said, you are likely to create many other bugs as you try to apply the code in this textbook to your own data. That is expected. Always remember to read each line of your Python code carefully and, if you have an error message, identify where the error is coming from and what it is."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ML4DWISE",
    "section": "",
    "text": "Machine Learning For The Wise - ML4DWISE\n\n\n\nML4DWISE\n\n\nThis course is designed for those who desire to seize the opportunity of building intelligent machines – a pursuit reserved for the wise. The digital age is undeniably entering an era dominated by artificial intelligence (AI). To achieve this level of intelligence, machines must be taught, or trained. This is where machine learning (ML) comes in. It empowers computers to learn from data without explicit programming, enabling them to identify patterns and make predictions based on the information provided.\nEveryone’s unique knowledge, experience, and expertise are invaluable in developing these intelligent machines. For instance, the input of a doctor is crucial for creating an AI that can detect early stages of cancer. AI is poised to revolutionize every field, alleviating drudgery and boosting productivity, ultimately redefining the nature of work.\nWhile there’s speculation about AI taking jobs, the reality is stark: 100% of jobs will be impacted. However, there’s good news for two groups: those who leverage AI to enhance their productivity and those who build it. This course empowers you to both harness the power of AI and contribute to its development.\nHere’s the course curriculum, designed to equip the wise with the necessary skills to build intelligent machines. It progresses from problem solving with Python, to super-charged productivity by leveraging AI, and then to building intelligent machines with ML, culminating in a practical capstone project.\n\nCurriculum\n\nPROBLEM SOLVING WITH PYTHON\n\n\nGoal: Develop proficiency in Python and foundational programming concepts essential for Machine Learning.\n\n1.1 Introduction To Python\n\nUnderstanding Python’s popularity in AI/ML.\nSetting up the development environment (Anaconda, Jupyter Notebooks).\nPython basics: variables, data types, input/output, debugging.\n\n1.2 Data and Data Structures\n\nData: numbers, strings, boolean.\nData structures: lists, tuples, sets, dictionaries.\n\n1.3 Loops and Logic\n\nLoops: iterations, for-loop, while-loop.\nConditionals: if, else, elif.\n\n1.4 Formal Coding\n\nFunctions.\nClasses.\nLibraries in Python.\n\n1.5 Working With Data\n\nData collection and input methods.\nData manipulation with Pandas.\nData visualization using Matplotlib.\n\nPractical: Analyze and visualize a real-world dataset (e.g., COVID-19 trends).\n\n\n\nACCELERATED SOLUTIONS WITH AI\n\n\nGoal: Explore AI tools and techniques to accelerate problem-solving and creativity.\n\n2.1 Artificial Intelligence Introduction\n\nBasics of AI: what it is, types, and real-world use cases.\nAI tools: ChatGPT, NotebookLM, Meta AI, Perplexity, Runway.\n\n2.2 Prompt Engineering\n\nCrafting effective prompts for generative AI.\nTechniques for optimizing output for text, images, and audio.\n\n2.3 Working with Text\n\nGenerating articles, emails, and reports.\nSummarization and language translation using AI.\n\n2.4 Working with Images\n\nText-to-image generation (e.g., DALL-E, Stable Diffusion).\nEditing and enhancing images using AI tools.\n\n2.5 Working with Audio\n\nAI for voice synthesis and speech-to-text.\nBasics of music generation with AI.\n\nPractical: Generate promotional content (text, image, audio) for a mock brand.\n\n\n\nBUILDING INTELLIGENCE SYSTEMS WITH ML\n\n\nGoal: Gain deep expertise in Machine Learning to create intelligent systems for diverse applications.\n\n3.1 Machine Learning Introduction\n\nKey concepts: supervised, unsupervised, reinforcement learning.\nML tools: Hugging Face, Jupyter Notebook, Transformers.\n\n3.2 Text ML (Natural Language Processing)\n\nText preprocessing: tokenization, stemming, lemmatization.\nText classification and sentiment analysis.\nBuilding chatbots with transformer models.\n\n3.3 Image ML\n\nImage preprocessing and augmentation.\nConvolutional Neural Networks (CNNs).\nObject detection and segmentation.\n\n3.4 Audio ML\n\nPreprocessing audio signals.\nSpeech recognition and classification.\nAudio synthesis and generation.\n\nPractical: Create a sentiment analyzer using Hugging Face. CAPSTONE PROJECT:\n\nGoal: Combine the skills learned across all modules to solve a real-world problem.\nProject: Build an intelligent virtual assistant."
  },
  {
    "objectID": "python.html",
    "href": "python.html",
    "title": "Python",
    "section": "",
    "text": "In the rapidly evolving landscape of artificial intelligence and machine learning, Python has emerged as the de facto programming language of choice for developers, researchers, and data scientists. Its dominance in these fields is no coincidence – Python offers a unique combination of features and advantages that make it exceptionally well-suited for AI and ML development."
  },
  {
    "objectID": "python.html#why-python",
    "href": "python.html#why-python",
    "title": "Python",
    "section": "Why Python",
    "text": "Why Python\n\nRich Libraries\nOne of Python’s greatest strengths lies in its extensive ecosystem of specialized libraries and frameworks for machine learning and AI. Libraries like TensorFlow, PyTorch, and scikit-learn provide robust foundations for developing sophisticated machine learning models. NumPy offers powerful tools for numerical computing, while Pandas excels at data manipulation and analysis. These libraries, maintained by both tech giants and the open-source community, provide pre-built components that significantly reduce development time and complexity.\n\n\n\neasy-python-just-import\n\n\n\n\nEasy to Learn and Use\nPython’s syntax is remarkably intuitive and readable, often described as “pseudocode that runs.” This characteristic is particularly valuable in machine learning, where complex algorithms and mathematical concepts need to be translated into executable code. The language’s emphasis on readability and simplicity means that developers can focus on solving machine learning problems rather than wrestling with complicated syntax.\nConsider this simple example of a machine learning model in Python:\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\n\n# Split data and train model\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\nThe code above is self-explanatory even to those with basic programming knowledge, demonstrating Python’s emphasis on clarity and simplicity.\n\n\nThriving Open-Source Community\nPython’s open-source nature has fostered a vibrant, collaborative community that continuously contributes to its growth. This community-driven development has resulted in: - Regular updates and improvements to existing libraries - Extensive documentation and tutorials - Quick bug fixes and security patches - Readily available support through forums and discussion boards\nThe collaborative spirit of Python’s community has accelerated innovation in AI and machine learning, making cutting-edge technologies more accessible to developers worldwide.\n\n\n\npython, most popular on github\n\n\n\n\nWidespread Popularity\nPython’s popularity in the AI and ML space creates a positive feedback loop: more developers using Python leads to more resources, tools, and job opportunities, which in turn attracts more developers. According to recent surveys, Python consistently ranks as one of the most popular programming languages, particularly in data science and machine learning roles. This widespread adoption means: - Abundant learning resources - Large talent pool for organizations - Extensive code examples and solutions - Regular updates and maintenance of ML libraries\n\n\nPlatform Independence\nPython’s cross-platform compatibility is crucial for machine learning applications that need to run in various environments. Whether developing on Windows, macOS, or Linux, Python code remains consistent and portable. This platform independence enables: - Seamless deployment across different operating systems - Easy scaling from development to production - Consistent performance across platforms - Flexibility in choosing development and deployment environments\nPython provides the tools, resources, and ecosystem necessary for the wise the opportunity of building intelligent machines."
  },
  {
    "objectID": "python.html#setting-up-a-python-development-environment",
    "href": "python.html#setting-up-a-python-development-environment",
    "title": "Python",
    "section": "Setting Up a Python Development Environment",
    "text": "Setting Up a Python Development Environment\nWhen embarking on Python development, especially for AI/ML projects, establishing a robust development environment is crucial.\n\nExploring Options\nSeveral options exist, each with its own advantages: * Local Installation: * Pros: Complete control, offline access, and customization. * Cons: Requires manual installation and configuration, potential for conflicts, and resource management on your machine. * Popular choices: Anaconda, virtual environments (venv, virtualenv). * Cloud-Based Environments: * Pros: No local setup needed, scalable resources, easy collaboration, and often free tiers. * Cons: Reliance on internet connectivity, potential for vendor lock-in, and limited control over underlying hardware. * Popular choices: Google Colaboratory, Amazon SageMaker, Google Cloud AI Platform Notebooks, Microsoft Azure Notebooks.\n\n\nColab Notebooks\nDeveloping with Jupyter Notebooks on Google Colaboratory (Colab) provides a seamless and user-friendly platform for Python development, particularly for AI/ML. Here’s how to get started: * Access Colab: * Visit the Colab website: https://colab.research.google.com/ * Create a new notebook by clicking “New Notebook”. * Write and Execute Code: * Colab offers a web-based interface where you can write and execute Python code in cells. * Each cell can contain code, Markdown for documentation, or even LaTeX for mathematical equations. * Execute code by clicking the “Play” button or using the keyboard shortcut (Shift+Enter). * Utilize AI/ML Libraries: * Colab comes pre-installed with many essential AI/ML libraries like TensorFlow, PyTorch, scikit-learn, and more. * You can easily import and use these libraries within your notebook. * Leverage Colab’s Features: * GPU/TPU Acceleration: Colab provides access to GPUs and TPUs, significantly accelerating the training of deep learning models. * Large File Handling: Colab integrates with Google Drive, allowing you to easily load and save large datasets. * Collaboration: Share your notebooks with others and collaborate in real-time. Key Advantages of Colab for AI/ML: * Free to Use: Colab offers a free tier with access to GPUs, making it accessible to all. * User-Friendly: The intuitive interface and pre-installed libraries simplify the development process. * Scalability: Easily scale your resources to accommodate larger datasets and more complex models. By leveraging the power of Jupyter Notebooks on Google Colab, you can efficiently develop and experiment with AI/ML models, regardless of your computational resources."
  },
  {
    "objectID": "python.html#python-basics-a-comprehensive-guide-for-beginners",
    "href": "python.html#python-basics-a-comprehensive-guide-for-beginners",
    "title": "Python",
    "section": "Python Basics: A Comprehensive Guide for Beginners",
    "text": "Python Basics: A Comprehensive Guide for Beginners\n\n1. Variables and Assignment\nVariables in Python are dynamically typed, meaning you don’t need to declare their type explicitly. Here’s how to work with them:\n# Basic variable assignment\nname = \"John\"\nage = 25\nheight = 1.75\nis_student = True\n\n# Multiple assignment\nx, y, z = 1, 2, 3\n\n# Print variable types\nprint(type(name))    # &lt;class 'str'&gt;\nprint(type(age))     # &lt;class 'int'&gt;\nprint(type(height))  # &lt;class 'float'&gt;\nprint(type(is_student))  # &lt;class 'bool'&gt;\n\n# Variable naming conventions\nfirst_name = \"John\"    # Snake case (recommended)\nlastName = \"Doe\"       # Camel case\nPI = 3.14159          # Constants (uppercase)\n\n\n2. Data Types\n\nNumbers\n# Integers\nx = 5\ny = -10\nbig_number = 1_000_000  # Underscores for readability\n\n# Floating-point numbers\npi = 3.14159\nscientific = 2.5e-4\n\n# Complex numbers\ncomplex_num = 3 + 4j\n\n# Basic operations\nsum_result = x + y\nproduct = x * y\ndivision = x / y      # Float division\nfloor_div = x // y    # Integer division\nremainder = x % y     # Modulus\npower = x ** 2        # Exponentiation\n\n\nStrings\n# String creation\nsingle_quotes = 'Hello'\ndouble_quotes = \"World\"\nmulti_line = \"\"\"This is a\nmulti-line string\"\"\"\n\n# String operations\nfull_name = first_name + \" \" + lastName  # Concatenation\ngreeting = f\"Hello, {first_name}!\"       # f-strings\nrepeat = \"Ha\" * 3                        # Repetition\n\n# String methods\ntext = \"  Python Programming  \"\nprint(text.strip())          # Remove whitespace\nprint(text.upper())          # Convert to uppercase\nprint(text.lower())          # Convert to lowercase\nprint(text.replace(\"P\", \"J\")) # Replace characters\nprint(len(text))            # String length\n\n\nLists\n# List creation\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", 3.14, True]\n\n# List operations\nnumbers.append(6)           # Add element\nnumbers.insert(0, 0)        # Insert at position\nnumbers.remove(3)           # Remove element\npopped = numbers.pop()      # Remove and return last element\nnumbers.sort()              # Sort list\nnumbers.reverse()           # Reverse list\n\n# List slicing\nfirst_three = numbers[:3]   # First three elements\nlast_two = numbers[-2:]     # Last two elements\nstep_two = numbers[::2]     # Every second element\n\n\nDictionaries\n# Dictionary creation\nperson = {\n    \"name\": \"John\",\n    \"age\": 25,\n    \"city\": \"New York\"\n}\n\n# Dictionary operations\nperson[\"email\"] = \"john@example.com\"  # Add new key-value\ndel person[\"age\"]                     # Remove key-value\nkeys = person.keys()                  # Get all keys\nvalues = person.values()              # Get all values\n\n\n\n3. Input and Output\n\nBasic Input\n# Getting user input\nname = input(\"Enter your name: \")\nage = int(input(\"Enter your age: \"))  # Convert string to integer\nheight = float(input(\"Enter your height in meters: \"))  # Convert to float\n\n# Format output\nprint(f\"Name: {name}\")\nprint(f\"Age: {age}\")\nprint(f\"Height: {height:.2f} meters\")  # Format to 2 decimal places\n\n# Multiple output formats\nprint(\"Age:\", age)                     # Separate with comma\nprint(\"You are {} years old\".format(age))  # .format() method\nprint(\"Height: %.2f meters\" % height)  # %-formatting (old style)\n\n\nFile Input/Output\n# Writing to a file\nwith open('example.txt', 'w') as file:\n    file.write(\"Hello, World!\\n\")\n    file.write(\"This is a new line.\")\n\n# Reading from a file\nwith open('example.txt', 'r') as file:\n    content = file.read()          # Read entire file\n    print(content)\n\n# Reading line by line\nwith open('example.txt', 'r') as file:\n    for line in file:\n        print(line.strip())\n\n\n\n4. Debugging and Common Bugs\n\nCommon Errors and Solutions\n# 1. TypeError\nx = \"5\"\ny = 2\n# print(x + y)    # TypeError: can't concatenate str and int\nprint(int(x) + y) # Correct: Convert string to integer\n\n# 2. IndexError\nnumbers = [1, 2, 3]\n# print(numbers[3])  # IndexError: list index out of range\nprint(numbers[-1])   # Correct: Access last element\n\n# 3. KeyError\nperson = {\"name\": \"John\"}\n# print(person[\"age\"])  # KeyError: 'age'\nprint(person.get(\"age\", \"Not found\"))  # Correct: Use get() with default value\n\n# 4. IndentationError\ndef example():\nprint(\"Wrong indentation\")  # IndentationError\ndef correct_example():\n    print(\"Correct indentation\")\n\n\nDebugging Tips\n# Using print statements for debugging\ndef calculate_average(numbers):\n    print(f\"Input numbers: {numbers}\")  # Debug print\n    total = sum(numbers)\n    print(f\"Sum: {total}\")             # Debug print\n    average = total / len(numbers)\n    print(f\"Average: {average}\")       # Debug print\n    return average\n\n# Using assert statements\ndef divide(a, b):\n    assert b != 0, \"Division by zero!\"\n    return a / b\n\n# Try-except blocks for error handling\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    print(\"This always executes\")\n\n\n\n5. Best Practices\n\nVariable Naming:\n\nUse descriptive names\nFollow Python naming conventions\nAvoid reserved keywords\n\nCode Organization:\n\nUse proper indentation\nAdd comments for clarity\nBreak long lines (using )\n\nError Handling:\n\nUse try-except blocks\nValidate input data\nProvide meaningful error messages\n\nDebugging:\n\nUse print statements strategically\nImplement logging for larger projects\nTest code with different inputs\n\n\nRemember to practice these concepts by writing your own code and experimenting with different scenarios. The best way to learn Python is through hands-on experience and debugging your own code."
  }
]