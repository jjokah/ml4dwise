[
  {
    "objectID": "notebooks/intro.html",
    "href": "notebooks/intro.html",
    "title": "Introduction to Python",
    "section": "",
    "text": "Before we begin this book, let’s begin with a simple question. Why should humanists learn to code? To answer it, let’s consider the ideal digital humanities project.\nIn an ideal digital humanities project, a humanist (or team of humanists) will leverage their domain knowledge, or area of expertise. As a domain expert, this project leader, better known as principal investigator (PI), will convey their idea to their team which will consist of others in their field and usually a technical lead. This technical lead will (depending on funding) either handle all technical aspects of the project (web development, coding, data management, etc.) or lead a team to handle all technical aspects of it. This is the ideal scenario. Each person on the team does what they do best.\nSuch a project requires two things that are in high commodity to most researchers: funding and time. The self-reliant humanist who can leverage their domain knowledge while also being able to function in a technical capacity on a project drastically reduces both of these issues in several ways. To understand how, we must first understand how digital humanities projects receive funding.\n\n\nLarge digital projects often take years to begin. These projects often start with a researcher (or researchers) wishing to explore a question or create a digital platform for an aspect of their research. These scholars will then reach out to others in their field to gauge interest. This process can take several months to a year, especially if the researchers wait to present their idea at the next conference in their field.\nIf there is an interest in such a project, the project PI will find a technical expert who can tell them if it the project is possible and receive an estimate for its cost. If the PI does not have a technical expert and cannot find one associated with their university, this can be challenging and time-consuming. As we will see, the relationship between PI and technical lead is a unique bond that requires good communication from both parties. Selecting the right technical lead is important because their pay may be one of the larger budget items. It is also the person who makes the PI’s vision a digital reality.\nNext, the PI will create a list of funding opportunities for the project and then begin applying to them. Each application can take several months to complete. Once complete, the PI will then usually submit the application to the granting association through their university. If there are multiple PIs on the project at different universities, this process can be more complicated as all institutions usually need to communicate with each other.\nThe university will usually review all materials. They will be especially interested in the budget. This process can take a few weeks while the university ensures all numbers are accurate. After all, most universities will be taking a cut of the grant money (sometimes up to 30%), so they want to make sure they see the numbers first.\nAfter this, the university will submit the grant. Depending on the granting agency, the wait time can be anywhere from a few months to nearly a year. During this time, the digital project will may not move forward much, if at all. Rather, it may sit in a holding period while the PI waits to hear back.\nWhen we look at this timeline, it means that from initial idea to the start of the project, even in the ideal scenario, it can be realistically 2-3 years before the project begins. All of this comes with a bit of a gamble as well. The PI believes in the idea, they have also gauged the community to know that there is interest in it, and they have found a technical lead who can do the job, but a lot can happen in 2-3 years. In that time, new developments in the domain expert’s field may have altered the project trajectory (or, worst-case-scenario, made it redundant). Further, new digital approaches/methods may mean that an entirely new approach is necessary. This is especially common today if the project involves machine learning, a field in which new advances are happening every week. In addition to this, the technical lead may have taken a job elsewhere. (This does happen as they are not contracted until the grant is received). Finally, there is no guarantee that funding agencies value the idea. This means that the time spent designing the project conceptually and preparing to get started could be entirely in vain.\nBy learning to code, you can often negate this entire process by testing your idea within days or weeks. This means that you will be able to test the validity of the idea and potentially even create a minimum viable product (MVP) that can be used to assist in obtaining funding. An MVP is a working subset of a project to demonstrate its validity. For a digital humanities project, this may mean a simple front-end application or a subset of the data prepared a specific way. MVPs are quite common today in places like Silicon Valley, where MVPs are used to present an idea to investors. This helps give a real sense of how the project will work. While not all mechanics will be available in an MVP, it is a good proof-of-concept. It also demonstrates that the project is possible, the team can do the work they are promising, and that the team already has a good handle of the potential issues that may surface. These are all things that granting agencies like to see. Throughout this textbook, you will develop the skills necessary to create an MVP that you can present to a granting agency. This is especially true with the final chapter, where we learn how to build cloud-based Python applications with Streamlit.\n\n\n\nUltimately, the ability to code turns the humanist into an entirely self-reliant researcher. By learning to code, you can do far more than test out ideas and create MVPs. You can significantly reduce the cost of a digital humanities project. As a domain expert, you know your field well. As a coder, you will know what is technically possible. If you end up gaining an expertise in data science or machine learning (something that is quite realistic today as both fields are more accessible than ever), you can leverage some of the most powerful methods in technical fields within a digital humanities context. You can also eliminate many issues that may surface during a digital humanities project.\nOne problem is communication. The project PI needs the ability to communicate their ideas to the technical lead. This communication often occurs in a hybrid language that changes from team to team. The PI over time can begin to use technical terms and the technical lead will begin to use some domain-specific terms. This relationship and communication takes time to create. By having a strong command of the technical aspects of a project, the PI can either eliminate the need for a technical lead entirely or communicate their ideas to the technical side of the project in technical language.\nAnother issue that vanishes is the lag time from idea to execution. Once a funded project begins, the PI will guide their vision and convey each step to the technical lead whose job it is to make that vision a reality. There is a lag that exists here. Often, meetings on digital projects occur on a regular basis, sometimes weekly or bi-weekly. During that time, issues may surface that are placed on hold until the next meeting. This can put a digital project behind schedule. If the humanist is self-reliant, however, they can develop their idea independently of a technical lead. This means that when an issue surfaces, the PI can immediately rectify it and communicate the solution to the technical lead.\nThird, technical leads on projects usually absorb a lot of funding. Hiring a programmer can be costly, but if your project requires data science and machine learning, experts in these areas can costs hundreds of dollars per hour. If the PI has the technical expertise, they can perform technical aspects of a project until enough money is received to hire a technical lead.\n\n\n\nLearning to code gives the humanist tools beyond simply the ability to code. It fundamentally alters how the humanist views their field and the questions they can explore. Things that seemed impossible before, will suddenly appear quite simple to solve.\nOne of the greatest advantages of learning to code is automation, or the process by which we write rules for a computer to perform a repetitive task. As humanists, we do a lot of things repetitively. Many of the tasks we need to perform as humanists are repetitive and we, as humans, are prone to make mistakes. Being able to automate these tasks can radically reduce the amount of time we spend performing repetitive tasks, from hours, weeks, or even years, to seconds, minutes, or hours. Imagine having to grab data from an archive website. Imagine that the information you need is found on 2,000 different pages. How long would it take you to go to each of those pages and copy and paste the text into a Word Document? In Python, that task can be coded in minutes and left to run for an hour. This allows you, the researcher to go off and do some other task more essential; or, perhaps, enjoy a nice tea break in a hammock so that when you return to analyze the documents, you will be well-rested.\nCoding does not just allow us to automate tasks like this. It also allows us to systematically clean data. Imagine you wanted to search across PDF scans of medieval Latin. This problem presents many key issues that make such a task impossible or unreliable. First, medieval Latin did not have any firm spelling convention. This means that some scans may have variant spellings of words. Second, Latin is a highly inflected language, meaning word order is not important, rather the ending of a given word is. When combined with variant spellings, this means that each word can be represented sometimes hundreds of different ways. In addition to this, your texts are scans. Are those scans even searchable? If they are, was the OCR, or Optical Character Recognition, accurate? If it was done prior to 2015, it likely is not. If after, then the scans may be in a bad enough state where the OCR is not accurate. In addition to these problems, any OCR system will retain line breaks, meaning if the key word that you want to search for is hyphenated because the word is broken up between two lines, you need to account for that in your search. Next, we need to take into account editor notations, which often are noted in brackets, parentheses, and carrots. While this example is certainly a complex one, it is perfectly common. And while I am using Latin to demonstrate a greater issue with inflected languages, these same issues, especially those around OCR, surface with English texts as well. Coding allows us to address each and every one of these issues, some more easily than others.\nThe issue of searching is further complicated when this needs to be done for many documents simultaneously. Imagine if these issues surfaced in 5,000 different PDFs that you needed to analyze. Could you realistically run all these searches across 5,000 documents? If you could, would your results be good? To answer the former, yes, if you are willing to spend months doing it; to answer the latter, likely not. Programming allows for you to develop programs that perform all these tasks across all 5,000 documents. When you run a search, you will not simply hit ctrl+f. You will code your own search method so that your simple search can return very complex results that accounts for variance in the text.\nPython makes all of this possible."
  },
  {
    "objectID": "notebooks/intro.html#why-should-humanists-learn-to-code",
    "href": "notebooks/intro.html#why-should-humanists-learn-to-code",
    "title": "Introduction to Python",
    "section": "",
    "text": "Before we begin this book, let’s begin with a simple question. Why should humanists learn to code? To answer it, let’s consider the ideal digital humanities project.\nIn an ideal digital humanities project, a humanist (or team of humanists) will leverage their domain knowledge, or area of expertise. As a domain expert, this project leader, better known as principal investigator (PI), will convey their idea to their team which will consist of others in their field and usually a technical lead. This technical lead will (depending on funding) either handle all technical aspects of the project (web development, coding, data management, etc.) or lead a team to handle all technical aspects of it. This is the ideal scenario. Each person on the team does what they do best.\nSuch a project requires two things that are in high commodity to most researchers: funding and time. The self-reliant humanist who can leverage their domain knowledge while also being able to function in a technical capacity on a project drastically reduces both of these issues in several ways. To understand how, we must first understand how digital humanities projects receive funding.\n\n\nLarge digital projects often take years to begin. These projects often start with a researcher (or researchers) wishing to explore a question or create a digital platform for an aspect of their research. These scholars will then reach out to others in their field to gauge interest. This process can take several months to a year, especially if the researchers wait to present their idea at the next conference in their field.\nIf there is an interest in such a project, the project PI will find a technical expert who can tell them if it the project is possible and receive an estimate for its cost. If the PI does not have a technical expert and cannot find one associated with their university, this can be challenging and time-consuming. As we will see, the relationship between PI and technical lead is a unique bond that requires good communication from both parties. Selecting the right technical lead is important because their pay may be one of the larger budget items. It is also the person who makes the PI’s vision a digital reality.\nNext, the PI will create a list of funding opportunities for the project and then begin applying to them. Each application can take several months to complete. Once complete, the PI will then usually submit the application to the granting association through their university. If there are multiple PIs on the project at different universities, this process can be more complicated as all institutions usually need to communicate with each other.\nThe university will usually review all materials. They will be especially interested in the budget. This process can take a few weeks while the university ensures all numbers are accurate. After all, most universities will be taking a cut of the grant money (sometimes up to 30%), so they want to make sure they see the numbers first.\nAfter this, the university will submit the grant. Depending on the granting agency, the wait time can be anywhere from a few months to nearly a year. During this time, the digital project will may not move forward much, if at all. Rather, it may sit in a holding period while the PI waits to hear back.\nWhen we look at this timeline, it means that from initial idea to the start of the project, even in the ideal scenario, it can be realistically 2-3 years before the project begins. All of this comes with a bit of a gamble as well. The PI believes in the idea, they have also gauged the community to know that there is interest in it, and they have found a technical lead who can do the job, but a lot can happen in 2-3 years. In that time, new developments in the domain expert’s field may have altered the project trajectory (or, worst-case-scenario, made it redundant). Further, new digital approaches/methods may mean that an entirely new approach is necessary. This is especially common today if the project involves machine learning, a field in which new advances are happening every week. In addition to this, the technical lead may have taken a job elsewhere. (This does happen as they are not contracted until the grant is received). Finally, there is no guarantee that funding agencies value the idea. This means that the time spent designing the project conceptually and preparing to get started could be entirely in vain.\nBy learning to code, you can often negate this entire process by testing your idea within days or weeks. This means that you will be able to test the validity of the idea and potentially even create a minimum viable product (MVP) that can be used to assist in obtaining funding. An MVP is a working subset of a project to demonstrate its validity. For a digital humanities project, this may mean a simple front-end application or a subset of the data prepared a specific way. MVPs are quite common today in places like Silicon Valley, where MVPs are used to present an idea to investors. This helps give a real sense of how the project will work. While not all mechanics will be available in an MVP, it is a good proof-of-concept. It also demonstrates that the project is possible, the team can do the work they are promising, and that the team already has a good handle of the potential issues that may surface. These are all things that granting agencies like to see. Throughout this textbook, you will develop the skills necessary to create an MVP that you can present to a granting agency. This is especially true with the final chapter, where we learn how to build cloud-based Python applications with Streamlit.\n\n\n\nUltimately, the ability to code turns the humanist into an entirely self-reliant researcher. By learning to code, you can do far more than test out ideas and create MVPs. You can significantly reduce the cost of a digital humanities project. As a domain expert, you know your field well. As a coder, you will know what is technically possible. If you end up gaining an expertise in data science or machine learning (something that is quite realistic today as both fields are more accessible than ever), you can leverage some of the most powerful methods in technical fields within a digital humanities context. You can also eliminate many issues that may surface during a digital humanities project.\nOne problem is communication. The project PI needs the ability to communicate their ideas to the technical lead. This communication often occurs in a hybrid language that changes from team to team. The PI over time can begin to use technical terms and the technical lead will begin to use some domain-specific terms. This relationship and communication takes time to create. By having a strong command of the technical aspects of a project, the PI can either eliminate the need for a technical lead entirely or communicate their ideas to the technical side of the project in technical language.\nAnother issue that vanishes is the lag time from idea to execution. Once a funded project begins, the PI will guide their vision and convey each step to the technical lead whose job it is to make that vision a reality. There is a lag that exists here. Often, meetings on digital projects occur on a regular basis, sometimes weekly or bi-weekly. During that time, issues may surface that are placed on hold until the next meeting. This can put a digital project behind schedule. If the humanist is self-reliant, however, they can develop their idea independently of a technical lead. This means that when an issue surfaces, the PI can immediately rectify it and communicate the solution to the technical lead.\nThird, technical leads on projects usually absorb a lot of funding. Hiring a programmer can be costly, but if your project requires data science and machine learning, experts in these areas can costs hundreds of dollars per hour. If the PI has the technical expertise, they can perform technical aspects of a project until enough money is received to hire a technical lead.\n\n\n\nLearning to code gives the humanist tools beyond simply the ability to code. It fundamentally alters how the humanist views their field and the questions they can explore. Things that seemed impossible before, will suddenly appear quite simple to solve.\nOne of the greatest advantages of learning to code is automation, or the process by which we write rules for a computer to perform a repetitive task. As humanists, we do a lot of things repetitively. Many of the tasks we need to perform as humanists are repetitive and we, as humans, are prone to make mistakes. Being able to automate these tasks can radically reduce the amount of time we spend performing repetitive tasks, from hours, weeks, or even years, to seconds, minutes, or hours. Imagine having to grab data from an archive website. Imagine that the information you need is found on 2,000 different pages. How long would it take you to go to each of those pages and copy and paste the text into a Word Document? In Python, that task can be coded in minutes and left to run for an hour. This allows you, the researcher to go off and do some other task more essential; or, perhaps, enjoy a nice tea break in a hammock so that when you return to analyze the documents, you will be well-rested.\nCoding does not just allow us to automate tasks like this. It also allows us to systematically clean data. Imagine you wanted to search across PDF scans of medieval Latin. This problem presents many key issues that make such a task impossible or unreliable. First, medieval Latin did not have any firm spelling convention. This means that some scans may have variant spellings of words. Second, Latin is a highly inflected language, meaning word order is not important, rather the ending of a given word is. When combined with variant spellings, this means that each word can be represented sometimes hundreds of different ways. In addition to this, your texts are scans. Are those scans even searchable? If they are, was the OCR, or Optical Character Recognition, accurate? If it was done prior to 2015, it likely is not. If after, then the scans may be in a bad enough state where the OCR is not accurate. In addition to these problems, any OCR system will retain line breaks, meaning if the key word that you want to search for is hyphenated because the word is broken up between two lines, you need to account for that in your search. Next, we need to take into account editor notations, which often are noted in brackets, parentheses, and carrots. While this example is certainly a complex one, it is perfectly common. And while I am using Latin to demonstrate a greater issue with inflected languages, these same issues, especially those around OCR, surface with English texts as well. Coding allows us to address each and every one of these issues, some more easily than others.\nThe issue of searching is further complicated when this needs to be done for many documents simultaneously. Imagine if these issues surfaced in 5,000 different PDFs that you needed to analyze. Could you realistically run all these searches across 5,000 documents? If you could, would your results be good? To answer the former, yes, if you are willing to spend months doing it; to answer the latter, likely not. Programming allows for you to develop programs that perform all these tasks across all 5,000 documents. When you run a search, you will not simply hit ctrl+f. You will code your own search method so that your simple search can return very complex results that accounts for variance in the text.\nPython makes all of this possible."
  },
  {
    "objectID": "notebooks/intro.html#what-is-python",
    "href": "notebooks/intro.html#what-is-python",
    "title": "Introduction to Python",
    "section": "What is Python?",
    "text": "What is Python?\nPython is a programming language. Programming languages are ways that we, as humans, can write commands that will then be executed by a computer. There are many different programming languages available for humanists to choose from:\n\nC\nPython\nJavaScript\nR\nHTML (this is debatable)\n\nNot all programming languages are created equal. Some are best used for developing software, such as C; others are best suited for web development, such as HTML and JavaScript. And others are great at statistical analysis, R (and Python). Where does Python excel? Python excels in many areas. One thing that sets it apart from other programming languages for new coders is that it is easy to read and easy to write.\nIt is relatively easy to write compared to other programming languages because the syntax, or way in which you write tasks in code, is straightforward. It is easy to read because Python uses forced indentation. This means that blocks of code that can be difficult to read in other programming languages, are easily spotted in Python.\nSince it’s creation in the early 1990s, Python has soared in popularity which has, in turn, resulted in a large community of programmers and a large number of libraries available. We will learn about libraries later in this textbook. For now, think of libraries as large quantities of code that have already been written for you so that you can write 1 line of code to perform a complex task that may take hundreds or thousands of lines of code to write.\nToday, Python is one of the most widely used programming languages and is considered the essential language for text analysis, machine learning, data analysis (alongside R), web scrapping, and much more.\nPython (as of this writing) is currently in version 3.11.0. Let’s break each of these numbers down. The 3 refers to the main Python language. Python 2 still exists (in fact it comes standard on all Macs), but it is no longer supported and is slowly being replaced by Python 3. You should not invest time in learning Python 2 as it is only used to support legacy software and has a high number of security issues due to its depreciated status. This is important to note because certain things are coded differently between the two programming languages. If you were to look for help on a coding forum, such as StackOverflow, it is important to know about these distinctions.\nThe 11.0 in Python 3.11.0, tells us specifically what version of Python 3. Not all code from certain libraries is backwards compatible, meaning some libraries require a specific version of Python, so understanding this now as a concept will save confusion later. Each time a new version comes out, new features are available, so it is important to stay up-to-date with current versions, but it is not always essential."
  },
  {
    "objectID": "notebooks/intro.html#why-python",
    "href": "notebooks/intro.html#why-python",
    "title": "Introduction to Python",
    "section": "Why Python?",
    "text": "Why Python?\nFor all the above reasons, I encourage humanists to learn Python as their first programming language. It is one of the easiest languages to learn, straightforward to write, and can solve most of the programmatic problems a humanist may face. The large quantities of libraries and tutorials mean that there are few tasks that will prove impossible to do.\nIf you are sold on Python, then continue reading this textbook as we learn how to install it and use it as humanists."
  },
  {
    "objectID": "notebooks/next.html",
    "href": "notebooks/next.html",
    "title": "Coding Basics",
    "section": "",
    "text": "Before we jump into the textbook, we should cover a few basic aspects of programming that the reader may not know. These are some of the most essential terms and concepts that you will see used throughout this textbook. Remember, you can always come back to this section if you forget one of these terms."
  },
  {
    "objectID": "notebooks/next.html#the-print-function",
    "href": "notebooks/next.html#the-print-function",
    "title": "Coding Basics",
    "section": "The Print Function",
    "text": "The Print Function\nThe very first thing that every programmer learns is how to print something off using that programming language. In most tutorials, you will see the phrase “Hello, World!” used. In this textbook, let’s try something a bit different. Let’s say I wanted to print off “Hello, William”. We can do this in Python by using the print function. The print function lets us print off some piece of data. In our case, that piece of data will be a piece of text, known as a string (see below). Our text is “Hello, William”. The thing that we want to print off must be located between an open parentheses and a close parentheses. Let’s try to execute the print command in the cell below.\n\nprint(\"Hello, William!\")\n\nHello, William!\n\n\nAs we can see, the code that we typed in the Jupyter cell outputted beneath it. Now, it is your turn. Try to print off something. In order to print off text, you will need to use an open and a close quotation mark. We will learn more about this as we meet strings in the next chapter.\n\nfrom IPython.display import IFrame\nIFrame('https://trinket.io/embed/python3/3fe4c8f3f4', 700, 500)\n\n\n        \n        \n\n\nThis has worked wonderfully, but what if our Python notebook needs to be more dynamic, meaning it needs to adjust based on some user input. Perhaps, we need to use a name other than William based on some user-defined input. To do this, we would need to store a piece of data in memory. We can do this in Python by creating a variable that will point to an object. Before we get into how this is done, let’s first get to know objects and variables."
  },
  {
    "objectID": "notebooks/next.html#objects",
    "href": "notebooks/next.html#objects",
    "title": "Coding Basics",
    "section": "Objects",
    "text": "Objects\nWhen we import or create data within Python, we are essentially creating an object in memory with a variable. These two words, object and variable mean slightly different things, but are often used interchangeably. We will not get into the complexities of their differences and why they exist in this textbook, but for now, view an object as something that is created by a Python script and stored in your computer’s memory so that it can be used later in a program.\nThink of your computer’s memory rather like your own brain. Imagine if you needed to remember what the word for “hello” in German. You may use your memory rather like a flashcard, where “hello” in English equates to “hallo” in German. In Python, we create objects in a similar way. The object would be the dictionary entry of “hello: hallo”."
  },
  {
    "objectID": "notebooks/next.html#variables",
    "href": "notebooks/next.html#variables",
    "title": "Coding Basics",
    "section": "Variables",
    "text": "Variables\nIn order to reference this dictionary entry in memory, we need a way to reference it. We do this with a variable. The variable is simply the name of the item in our script that will point to that object in memory. Variables make it so that we can have an easy-to-remember name to reference, call, and change that object in memory.\nVariables can be created by typing a unique word, followed by an = sign, followed by the specific data. As we will learn throughout this chapter, there are many types of data that are created differently. Let’s create our first object before we begin. This will be a string, or a piece of text. (We will learn about these in more detail below.) In my case, I want to create the object author. I want author to be associated with my name in memory. In the cell, or block of code, below, let’s do this.\n\nauthor = \"William Mattingly\"\n\nExcellent! We have created our first object. Now, it is time to use that object. Below, we will learn about ways we can manipulate strings, but for now, let’s simply see if that object exists in memory. We can do this with the print function.\nThe print function will become your best friend in Python. It is, perhaps, the function I use most commonly. The reason for this is because the print function allows for you to easily debug, or identify problems and fix them, within your code. It allows us to print off objects that are stored in memory.\nTo use the print function, we type the word print followed by an open parentheses. After the open parentheses, we place the object or that piece of data that we want to print. After that, we close the function with the close parentheses. Let’s try to print off our new object author to make sure it is in memory.\n\nprint(author)\n\nWilliam Mattingly\n\n\nNotice that when I execute the cell above, I see an output that relates to the object we created above. What would happen if I tried to print off that object, but I used a capital letter, rather than a lowercase one at the beginning, so Author, rather than author?"
  },
  {
    "objectID": "notebooks/next.html#case-sensitivity",
    "href": "notebooks/next.html#case-sensitivity",
    "title": "Coding Basics",
    "section": "Case Sensitivity",
    "text": "Case Sensitivity\n\nprint(Author)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nInput In [3], in &lt;cell line: 1&gt;()\n----&gt; 1 print (Author)\n\nNameError: name 'Author' is not defined\n\n\n\nThe scary looking block of text above indicates that we have produced an error in Python. This mistake teaches us two things. First, Python is case sensitive. This means that if any object (or string) will need to be matched in not only letters, but also the case of those letters. Second, this mistake teaches us that we can only call objects that have been created and stored in memory.\nNow that we have the variable pointing to a specific piece of data, we can make our print function above a bit more dynamic. Let’s try and print off the same statement as before, but with the new full author name. I don’t expect you to understand the specifics of the code below, rather simply understand that we will frequently need to store variables in memory so that we can use them later in our programs.\n\nprint(f\"Hello, {author}!\")\n\nHello, William Mattingly!"
  },
  {
    "objectID": "notebooks/next.html#reserved-words",
    "href": "notebooks/next.html#reserved-words",
    "title": "Coding Basics",
    "section": "Reserved Words",
    "text": "Reserved Words\nWhen working with Python, there are a number of words known as reserve words. These are words that cannot be used as variable names. As of Python version 3.6, there are a total of 33 reserve words. In can sometimes be difficult to remember all of these reserve words, so Python has a nice built in function, “help”. If we execute the following command, we will see an entire list.\n\nhelp(\"keywords\")\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nThese are words that you cannot use as a variable name."
  },
  {
    "objectID": "notebooks/next.html#built-in-types",
    "href": "notebooks/next.html#built-in-types",
    "title": "Coding Basics",
    "section": "Built-in Types",
    "text": "Built-in Types\nIn addition to reserve words, there are also built-in types in Python. These are words that you can use (as we will see) to convert one type of data into another. There are 94 of these in total. Unlike reserve words, you can use a built-in type as a variable name. It is, however, strongly discouraged to do so because it will overwrite the intended use of these variable names in your script.\n\nimport builtins\n[getattr(builtins, d) for d in dir(builtins) if isinstance(getattr(builtins, d), type)]\n\n[ArithmeticError,\n AssertionError,\n AttributeError,\n BaseException,\n BlockingIOError,\n BrokenPipeError,\n BufferError,\n BytesWarning,\n ChildProcessError,\n ConnectionAbortedError,\n ConnectionError,\n ConnectionRefusedError,\n ConnectionResetError,\n DeprecationWarning,\n EOFError,\n OSError,\n Exception,\n FileExistsError,\n FileNotFoundError,\n FloatingPointError,\n FutureWarning,\n GeneratorExit,\n OSError,\n ImportError,\n ImportWarning,\n IndentationError,\n IndexError,\n InterruptedError,\n IsADirectoryError,\n KeyError,\n KeyboardInterrupt,\n LookupError,\n MemoryError,\n ModuleNotFoundError,\n NameError,\n NotADirectoryError,\n NotImplementedError,\n OSError,\n OverflowError,\n PendingDeprecationWarning,\n PermissionError,\n ProcessLookupError,\n RecursionError,\n ReferenceError,\n ResourceWarning,\n RuntimeError,\n RuntimeWarning,\n StopAsyncIteration,\n StopIteration,\n SyntaxError,\n SyntaxWarning,\n SystemError,\n SystemExit,\n TabError,\n TimeoutError,\n TypeError,\n UnboundLocalError,\n UnicodeDecodeError,\n UnicodeEncodeError,\n UnicodeError,\n UnicodeTranslateError,\n UnicodeWarning,\n UserWarning,\n ValueError,\n Warning,\n OSError,\n ZeroDivisionError,\n _frozen_importlib.BuiltinImporter,\n bool,\n bytearray,\n bytes,\n classmethod,\n complex,\n dict,\n enumerate,\n filter,\n float,\n frozenset,\n int,\n list,\n map,\n memoryview,\n object,\n property,\n range,\n reversed,\n set,\n slice,\n staticmethod,\n str,\n super,\n tuple,\n type,\n zip]\n\n\nOf this long list, I recommend paying particular attention to the ones that you are more likely to write naturally: bool, dict, float, int, list, map, object, property, range, reversed, set, slice, str, super, tuple, type, and zip. You are more likely to use these as variable names by accident than, say, ZeroDivisionError; and this shorter list is a lot easier to memorize."
  },
  {
    "objectID": "notebooks/next.html#type-function",
    "href": "notebooks/next.html#type-function",
    "title": "Coding Basics",
    "section": "Type Function",
    "text": "Type Function\nIt is frequently necessary to check to see what type of data a variable is. To identify this, you can use the built-in function type in Python. To use type, we use the command below with the data we want to analyze placed between the two parentheses.\n\ntype(\"this is a string...\")\n\nstr"
  },
  {
    "objectID": "notebooks/next.html#bugs",
    "href": "notebooks/next.html#bugs",
    "title": "Coding Basics",
    "section": "Bugs",
    "text": "Bugs\nThroughout your programming career, you will often read or hear about bugs. A bug is a problem in your code that either returns an error or an unintended result in the output. Tracing down bugs and fixing them is known as debugging. Aside from figuring out how to code solutions to problems, debugging can be one of the more time-consuming aspects of writing a program, especially if it is quite complex. Throughout this textbook, we will encounter common errors so that you can see them in this controlled space. We will also walk through what the error means and how to resolve it. That said, you are likely to create many other bugs as you try to apply the code in this textbook to your own data. That is expected. Always remember to read each line of your Python code carefully and, if you have an error message, identify where the error is coming from and what it is."
  }
]